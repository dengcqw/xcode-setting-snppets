<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDECodeSnippetCompletionScopes</key>
	<array>
		<string>All</string>
	</array>
	<key>IDECodeSnippetContents</key>
	<string>//Defining a function:
func jediGreet(name: String, ability: String) -&gt; (farewell: String, mayTheForceBeWithYou: String) {
    return ("Good bye, \(name).", " May the \(ability) be with you.")
}
//Calling a function:
let retValue = jediGreet("old friend", "Force")
println(retValue)
println(retValue.farewell)
println(retValue.mayTheForceBeWithYou)

//Function types
func sum(x: Int, y: Int) -&gt; (result: Int) { return x + y }
//has a function type of:
(Int, Int) -&gt; (Int)
//Function types can thus be used as parameters types or as return types for nesting functions.
    Passing and returning functions

//The following function is returning another function as its result which can be later assigned to a variable and called.
func jediTrainer () -&gt; ((String, Int) -&gt; String) {
    func train(name: String, times: Int) -&gt; (String) {
        return "\(name) has been trained in the Force \(times) times"
    }
    return train
}
let train = jediTrainer()
train("Obi Wan", 3)

//Variadic functions
//Variadic functions are functions that have a variable number of arguments (indicated by ... after the argument's type) that can be accessed into their body as an array.
func jediBladeColor (colors: String...) -&gt; () {
    for color in colors {
        println("\(color)")
    }
}
jediBladeColor("red","green")

//Defining a closure: {()-&gt;() in}

//Closures are typically enclosed in curly braces { } and are defined by a function type () -&gt; (), where -&gt; separates the arguments and the return type, followed by the in keyword which separates the closure header from its body.
{ (params) -&gt; returnType in
    statements
}
//An example could be the map function applied to an Array:
let padawans = ["Knox", "Avitla", "Mennaus"]
padawans.map({
    (padawan: String) -&gt; String in
    "\(padawan) has been trained!"
})

//Closures with known types:
//When the type of the closure's arguments are known, you can do as follows:
func applyMutliplication(value: Int, multFunction: Int -&gt; Int) -&gt; Int {
    return multFunction(value)
}

applyMutliplication(2, {value in
    value * 3
})

//Closures shorthand argument names:
//Closure arguments can be references by position ($0, $1, ...) rather than by name
applyMutliplication(2, {$0 * 3})

//Furthermore, when a closure is the last argument of a function, parenthesis can be omitted as such:
applyMutliplication(2) {$0 * 3}</string>
	<key>IDECodeSnippetIdentifier</key>
	<string>F92A1AA8-2258-4CBA-B658-5BDB5749FB7C</string>
	<key>IDECodeSnippetLanguage</key>
	<string>Xcode.SourceCodeLanguage.Swift</string>
	<key>IDECodeSnippetTitle</key>
	<string>Swift - closure function sample</string>
	<key>IDECodeSnippetUserSnippet</key>
	<true/>
	<key>IDECodeSnippetVersion</key>
	<integer>2</integer>
</dict>
</plist>
